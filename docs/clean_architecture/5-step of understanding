\CLEAN-ARCHITECTURE
‚îú‚îÄ‚îÄ‚îÄdata
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄdata-sources
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄmappers
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄmodels
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄrepositories
‚îú‚îÄ‚îÄ‚îÄdomain
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄentities
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄrepositories
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄservices
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄuse-cases
‚îú‚îÄ‚îÄ‚îÄpresentation
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄpure-components
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄui-adapters
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄview-models
‚îî‚îÄ‚îÄ‚îÄshared
    ‚îú‚îÄ‚îÄ‚îÄdi
    ‚îú‚îÄ‚îÄ‚îÄevents
    ‚îú‚îÄ‚îÄ‚îÄstore
    ‚îî‚îÄ‚îÄ‚îÄutils

# Data / data-sources
Vou analisar o conceito de **Data Sources** no contexto da Clean Architecture, especialmente para o seu projeto de finan√ßas pessoais.

## 1. **What is it?** - Entendendo o Conceito Fundamental

**Data Sources** s√£o abstra√ß√µes que representam as fontes de dados da aplica√ß√£o. Na Clean Architecture, elas fazem parte da **Data Layer** e s√£o respons√°veis por:

- **Abstrair a origem dos dados** (SQLite, APIs, arquivos, etc.)
- **Fornecer interface padronizada** para acesso a dados
- **Isolar a implementa√ß√£o espec√≠fica** de cada fonte de dados
- **Permitir troca de fontes** sem afetar o dom√≠nio

### Exemplo Pr√°tico no Seu Projeto:
```typescript
// ‚ùå ANTES - Acesso direto ao SQLite
const operations = await db.getAllAsync('SELECT * FROM operations');

// ‚úÖ DEPOIS - Data Source abstrato
interface IOperationDataSource {
  getAll(): Promise<Operation[]>;
  save(operation: Operation): Promise<void>;
  update(id: string, operation: Partial<Operation>): Promise<void>;
  delete(id: string): Promise<void>;
}
```

## 2. **When to use and when not to use it?** - Aplica√ß√µes e Casos de Uso

### ‚úÖ **Quando USAR Data Sources:**

**1. M√∫ltiplas Fontes de Dados:**
```typescript
// Seu projeto pode ter:
- SQLite (dados locais)
- API REST (sincroniza√ß√£o)
- Cache em mem√≥ria
- Backup em arquivo
```

**2. Testes Unit√°rios:**
```typescript
// Mock para testes
class MockOperationDataSource implements IOperationDataSource {
  async getAll(): Promise<Operation[]> {
    return [mockOperation1, mockOperation2];
  }
}
```

**3. Migra√ß√£o de Tecnologias:**
```typescript
// Trocar SQLite por Realm sem afetar dom√≠nio
class RealmOperationDataSource implements IOperationDataSource {
  // Implementa√ß√£o espec√≠fica do Realm
}
```

### ‚ùå **Quando N√ÉO USAR Data Sources:**

**1. Projetos Muito Simples:**
- Aplica√ß√£o com apenas uma fonte de dados
- Sem necessidade de testes isolados
- Sem planos de mudan√ßa de tecnologia

**2. Over-engineering:**
- Adicionar complexidade desnecess√°ria
- Quando a abstra√ß√£o n√£o traz benef√≠cios reais

## 3. **Why use it?** - Raz√µes e Benef√≠cios

### üéØ **Benef√≠cios Principais:**

**1. Desacoplamento:**
```typescript
// Domain n√£o conhece SQLite
export class CreateOperationUseCase {
  constructor(private dataSource: IOperationDataSource) {}
  // N√£o importa se √© SQLite, API, ou arquivo
}
```

**2. Testabilidade:**
```typescript
// Teste isolado sem banco real
describe('CreateOperationUseCase', () => {
  it('should create operation', async () => {
    const mockDataSource = new MockOperationDataSource();
    const useCase = new CreateOperationUseCase(mockDataSource);
    // Teste sem depend√™ncias externas
  });
});
```

**3. Flexibilidade:**
```typescript
// Trocar implementa√ß√£o facilmente
const dataSource = isOnline 
  ? new APIOperationDataSource() 
  : new SQLiteOperationDataSource();
```

**4. Manutenibilidade:**
```typescript
// Mudan√ßas na fonte n√£o afetam dom√≠nio
class SQLiteOperationDataSource implements IOperationDataSource {
  async getAll(): Promise<Operation[]> {
    // Mudan√ßas aqui n√£o quebram o resto
    return await this.db.getAllAsync('SELECT * FROM operations');
  }
}
```

## 4. **What are the basic concepts?** - Conceitos Fundamentais

### üîß **Conceitos B√°sicos:**

**1. Interface Contract:**
```typescript
// Contrato que define o que a fonte deve fazer
interface IOperationDataSource {
  getAll(): Promise<Operation[]>;
  getById(id: string): Promise<Operation | null>;
  save(operation: Operation): Promise<void>;
  update(id: string, operation: Partial<Operation>): Promise<void>;
  delete(id: string): Promise<void>;
  findByDateRange(start: Date, end: Date): Promise<Operation[]>;
}
```

**2. Implementation:**
```typescript
// Implementa√ß√£o concreta
class SQLiteOperationDataSource implements IOperationDataSource {
  constructor(private db: SQLiteDatabase) {}
  
  async getAll(): Promise<Operation[]> {
    const result = await this.db.getAllAsync('SELECT * FROM operations');
    return result.map(this.mapToOperation);
  }
}
```

**3. Dependency Injection:**
```typescript
// Inje√ß√£o da implementa√ß√£o correta
class OperationRepository {
  constructor(private dataSource: IOperationDataSource) {}
  
  async getAllOperations(): Promise<Operation[]> {
    return await this.dataSource.getAll();
  }
}
```

**4. Error Handling:**
```typescript
// Tratamento de erros padronizado
class SQLiteOperationDataSource implements IOperationDataSource {
  async getAll(): Promise<Operation[]> {
    try {
      const result = await this.db.getAllAsync('SELECT * FROM operations');
      return result.map(this.mapToOperation);
    } catch (error) {
      throw new DataSourceError('Failed to fetch operations', error);
    }
  }
}
```

## 5. **How to use it?** - Aplica√ß√£o Pr√°tica
## **How to use it?** - Aplica√ß√£o Pr√°tica dos Data Sources

Vou explicar como usar Data Sources de forma pr√°tica no seu projeto, sem codificar:

### **ÔøΩÔøΩ 1. Configura√ß√£o Inicial**

#### **Passo 1: Definir as Interfaces**
Primeiro, voc√™ define **o que** cada fonte de dados deve fazer, n√£o **como**:

```typescript
// Contrato claro e espec√≠fico
interface IOperationDataSource {
  getAll(): Promise<Operation[]>;
  save(operation: Operation): Promise<void>;
  findByDateRange(start: Date, end: Date): Promise<Operation[]>;
}
```

#### **Passo 2: Registrar no Container DI**
Configure qual implementa√ß√£o usar:

```typescript
// Registra a implementa√ß√£o SQLite
container.registerSingleton<IOperationDataSource>(
  'IOperationDataSource',
  () => new SQLiteOperationDataSource()
);
```

### **üîß 2. Uso no Dom√≠nio**

#### **Nos Casos de Uso:**
```typescript
// O dom√≠nio n√£o sabe se √© SQLite, API, ou arquivo
class CreateOperationUseCase {
  constructor(private dataSource: IOperationDataSource) {}
  
  async execute(data: CreateOperationRequest): Promise<Result<Operation>> {
    // Apenas regras de neg√≥cio
    const operation = new Operation(data);
    await this.dataSource.save(operation);
    return success(operation);
  }
}
```

#### **Nos Reposit√≥rios:**
```typescript
// Reposit√≥rio usa o Data Source
class OperationRepository {
  constructor(private dataSource: IOperationDataSource) {}
  
  async getAll(): Promise<Operation[]> {
    return await this.dataSource.getAll();
  }
}
```

### **üß™ 3. Uso em Testes**

#### **Teste Unit√°rio:**
```typescript
describe('CreateOperationUseCase', () => {
  it('should create operation', async () => {
    // Mock simples e r√°pido
    const mockDataSource = {
      save: jest.fn().mockResolvedValue(undefined)
    };
    
    const useCase = new CreateOperationUseCase(mockDataSource);
    const result = await useCase.execute(testData);
    
    expect(result.isSuccess()).toBe(true);
    expect(mockDataSource.save).toHaveBeenCalled();
  });
});
```

#### **Teste de Integra√ß√£o:**
```typescript
describe('OperationRepository Integration', () => {
  it('should save and retrieve operation', async () => {
    // Usa implementa√ß√£o real do SQLite
    const dataSource = new SQLiteOperationDataSource();
    const repository = new OperationRepository(dataSource);
    
    const operation = new Operation(testData);
    await repository.save(operation);
    
    const retrieved = await repository.getById(operation.id);
    expect(retrieved).toEqual(operation);
  });
});
```

### **üîÑ 4. Troca de Implementa√ß√µes**

#### **Mudan√ßa de SQLite para API:**
```typescript
// Antes
container.registerSingleton<IOperationDataSource>(
  'IOperationDataSource',
  () => new SQLiteOperationDataSource()
);

// Depois - apenas muda a implementa√ß√£o
container.registerSingleton<IOperationDataSource>(
  'IOperationDataSource',
  () => new APIOperationDataSource(apiConfig)
);

// O resto do c√≥digo n√£o muda!
```

#### **M√∫ltiplas Fontes:**
```typescript
// Cache + SQLite
class CachedOperationDataSource implements IOperationDataSource {
  constructor(
    private cache: IOperationDataSource,
    private primary: IOperationDataSource
  ) {}
  
  async getAll(): Promise<Operation[]> {
    // Tenta cache primeiro, depois SQLite
    try {
      return await this.cache.getAll();
    } catch {
      const data = await this.primary.getAll();
      await this.cache.saveAll(data);
      return data;
    }
  }
}
```

### **ÔøΩÔøΩ 5. Uso em Cen√°rios Reais**

#### **Cen√°rio 1: Aplica√ß√£o Offline-First**
```typescript
// Estrat√©gia baseada na conectividade
const dataSource = isOnline 
  ? new APIOperationDataSource() 
  : new SQLiteOperationDataSource();

// O dom√≠nio n√£o precisa saber da diferen√ßa
const useCase = new CreateOperationUseCase(dataSource);
```

#### **Cen√°rio 2: Migra√ß√£o de Dados**
```typescript
// Migra√ß√£o gradual
class MigrationDataSource implements IOperationDataSource {
  constructor(
    private oldSource: IOperationDataSource,
    private newSource: IOperationDataSource
  ) {}
  
  async save(operation: Operation): Promise<void> {
    // Salva nos dois lugares durante migra√ß√£o
    await Promise.all([
      this.oldSource.save(operation),
      this.newSource.save(operation)
    ]);
  }
}
```

#### **Cen√°rio 3: Backup Autom√°tico**
```typescript
// Backup transparente
class BackupDataSource implements IOperationDataSource {
  constructor(
    private primary: IOperationDataSource,
    private backup: IOperationDataSource
  ) {}
  
  async save(operation: Operation): Promise<void> {
    await this.primary.save(operation);
    // Backup em background
    this.backup.save(operation).catch(console.error);
  }
}
```

### **üé® 6. Padr√µes de Uso Comuns**

#### **Repository Pattern:**
```typescript
// Reposit√≥rio abstrai o Data Source
class OperationRepository {
  constructor(private dataSource: IOperationDataSource) {}
  
  async findByCategory(category: string): Promise<Operation[]> {
    const all = await this.dataSource.getAll();
    return all.filter(op => op.category === category);
  }
}
```

#### **Unit of Work:**
```typescript
// Transa√ß√µes complexas
class UnitOfWork {
  constructor(private dataSource: IOperationDataSource) {}
  
  async executeTransaction(operations: Operation[]): Promise<void> {
    // L√≥gica de transa√ß√£o
    for (const op of operations) {
      await this.dataSource.save(op);
    }
  }
}
```

### **üîç 7. Benef√≠cios Pr√°ticos**

#### **Desenvolvimento:**
- **Desenvolvimento paralelo**: Equipe pode trabalhar em Data Sources diferentes
- **Testes r√°pidos**: Mocks simples para testes unit√°rios
- **Debugging f√°cil**: Troca implementa√ß√£o para debug

#### **Manuten√ß√£o:**
- **Mudan√ßas isoladas**: Troca SQLite por Realm sem afetar dom√≠nio
- **Performance**: Adiciona cache sem mudar l√≥gica de neg√≥cio
- **Monitoramento**: Adiciona logs sem afetar funcionalidade

#### **Escalabilidade:**
- **M√∫ltiplas fontes**: Cache + API + SQLite
- **Migra√ß√£o gradual**: Implementa nova fonte aos poucos
- **Fallbacks**: Implementa estrat√©gias de retry/fallback

### **üìã 8. Checklist de Implementa√ß√£o**

#### **Antes de Implementar:**
- [ ] Interface bem definida
- [ ] Casos de uso identificados
- [ ] Estrat√©gia de erro definida
- [ ] Plano de testes

#### **Durante Implementa√ß√£o:**
- [ ] Implementa√ß√£o concreta
- [ ] Tratamento de erros
- [ ] Valida√ß√µes
- [ ] Logs/monitoramento

#### **Ap√≥s Implementa√ß√£o:**
- [ ] Testes unit√°rios
- [ ] Testes de integra√ß√£o
- [ ] Performance testing
- [ ] Documenta√ß√£o

### 9. Dicas Pr√°ticas

#### **Nomenclatura:**
- Use prefixo `I` para interfaces: `IOperationDataSource`
- Use sufixo descritivo: `SQLiteOperationDataSource`
- Use nomes claros: `MockOperationDataSource`

#### **Organiza√ß√£o:**
- Interfaces no dom√≠nio
- Implementa√ß√µes na data layer
- Mocks em pasta de testes

#### **Documenta√ß√£o:**
- Documente contratos das interfaces
- Exemplos de uso
- Casos de erro e tratamento

Essa abordagem garante que seu c√≥digo seja **flex√≠vel**, **test√°vel** e **manuten√≠vel**, permitindo evolu√ß√£o da aplica√ß√£o sem quebrar funcionalidades existentes.

# Data / data-mappers
## **Data / data-mappers** - 5-Step Complete Understanding Framework

### 1. **What is it?** - Entendendo o Conceito Fundamental

**Data Mappers** s√£o componentes respons√°veis por **converter dados** entre diferentes representa√ß√µes da mesma informa√ß√£o. Na Clean Architecture, eles fazem parte da **Data Layer** e s√£o respons√°veis por:

- **Converter dados do banco** para entidades de dom√≠nio
- **Converter entidades de dom√≠nio** para formato do banco
- **Isolar diferen√ßas de estrutura** entre camadas
- **Manter integridade dos dados** durante convers√µes

#### **Problema que resolve:**
```typescript
// ‚ùå SEM MAPPER - Mistura de responsabilidades
const operation = {
  id: row.id,
  nature: row.nature,
  value: row.value, // number do banco
  date: row.date,   // string do banco
  // ... mais campos
};

// ‚ùå PROBLEMA: L√≥gica de convers√£o espalhada
const domainOperation = new Operation({
  id: operation.id,
  nature: operation.nature,
  value: new Money(operation.value), // Convers√£o manual
  date: new Date(operation.date),    // Convers√£o manual
});
```

### 2. **When to use and when not to use it?** - Aplica√ß√µes e Casos de Uso

#### ‚úÖ **Quando USAR Data Mappers:**

**1. Estruturas Diferentes:**
- Banco usa `snake_case`, dom√≠nio usa `camelCase`
- Banco usa `string` para data, dom√≠nio usa `Date`
- Banco usa `number` para valor, dom√≠nio usa `Money` object

**2. M√∫ltiplas Fontes de Dados:**
- SQLite, API REST, arquivos JSON
- Cada fonte tem estrutura diferente
- Precisa normalizar para o dom√≠nio

**3. Valida√ß√µes e Transforma√ß√µes:**
- Dados do banco podem estar "sujos"
- Precisa validar antes de criar entidades
- Transforma√ß√µes complexas (ex: timezone, formata√ß√£o)

**4. Evolu√ß√£o de Schema:**
- Banco mudou estrutura
- API mudou formato
- Precisa manter compatibilidade

#### ‚ùå **Quando N√ÉO USAR Data Mappers:**

**1. Estruturas Id√™nticas:**
- Banco e dom√≠nio usam exatamente a mesma estrutura
- N√£o h√° diferen√ßas de tipo ou formato
- Convers√µes s√£o triviais

**2. Projetos Muito Simples:**
- Aplica√ß√£o com uma √∫nica fonte de dados
- Estruturas sempre sincronizadas
- Sem necessidade de valida√ß√µes complexas

**3. Over-engineering:**
- Adicionar complexidade desnecess√°ria
- Quando a convers√£o √© simples demais
- Quando n√£o h√° benef√≠cios reais

### 3. **Why use it?** - Raz√µes e Benef√≠cios

#### üéØ **Benef√≠cios Principais:**

**1. Separa√ß√£o de Responsabilidades:**
```typescript
// ‚úÖ COM MAPPER - Responsabilidades claras
class OperationMapper {
  toDomain(data: OperationData): Operation {
    // Apenas convers√£o de dados
    return new Operation({
      id: data.id,
      value: new Money(data.value),
      date: new Date(data.date)
    });
  }
  
  toData(operation: Operation): OperationData {
    // Apenas convers√£o para banco
    return {
      id: operation.id,
      value: operation.value.toNumber(),
      date: operation.date.toISOString()
    };
  }
}
```

**2. Manutenibilidade:**
- Mudan√ßas no banco afetam apenas o mapper
- Mudan√ßas no dom√≠nio afetam apenas o mapper
- L√≥gica de convers√£o centralizada

**3. Testabilidade:**
```typescript
// Teste isolado do mapper
describe('OperationMapper', () => {
  it('should convert database data to domain', () => {
    const data = { id: '1', value: 100.50, date: '2024-01-01' };
    const operation = mapper.toDomain(data);
    
    expect(operation.value).toBeInstanceOf(Money);
    expect(operation.date).toBeInstanceOf(Date);
  });
});
```

**4. Flexibilidade:**
- Trocar banco de dados sem afetar dom√≠nio
- Adicionar valida√ß√µes sem afetar outras camadas
- Suportar m√∫ltiplos formatos de dados

**5. Integridade dos Dados:**
- Valida√ß√£o durante convers√£o
- Tratamento de dados inv√°lidos
- Normaliza√ß√£o de formatos

### 4. **What are the basic concepts?** - Conceitos Fundamentais

#### üîß **Conceitos B√°sicos:**

**1. Bidirecional Mapping:**
```typescript
interface IMapper<TDomain, TData> {
  toDomain(data: TData): TDomain;
  toData(domain: TDomain): TData;
}
```

**2. Type Safety:**
- Convers√µes tipadas
- Valida√ß√£o de tipos
- Tratamento de erros

**3. Immutability:**
- N√£o modifica dados originais
- Cria novas inst√¢ncias
- Preserva integridade

**4. Error Handling:**
```typescript
class MappingError extends Error {
  constructor(message: string, originalData: any) {
    super(`Mapping failed: ${message}`);
    this.originalData = originalData;
  }
}
```

**5. Validation:**
- Valida dados antes da convers√£o
- Rejeita dados inv√°lidos
- Fornece mensagens claras

**6. Factory Methods:**
```typescript
class OperationMapper {
  static create(): OperationMapper {
    return new OperationMapper();
  }
  
  static fromData(data: OperationData): Operation {
    return new OperationMapper().toDomain(data);
  }
}
```

### 5. **How to use it?** - Aplica√ß√£o Pr√°tica

#### **üîÑ Fluxo de Uso:**

**1. Configura√ß√£o:**
```typescript
// Registrar mapper no container
container.registerSingleton<OperationMapper>(
  'OperationMapper',
  () => new OperationMapper()
);
```

**2. Uso no Data Source:**
```typescript
class SQLiteOperationDataSource {
  constructor(private mapper: OperationMapper) {}
  
  async getAll(): Promise<Operation[]> {
    const rows = await this.db.getAllAsync('SELECT * FROM operations');
    return rows.map(row => this.mapper.toDomain(row));
  }
  
  async save(operation: Operation): Promise<void> {
    const data = this.mapper.toData(operation);
    await this.db.runAsync('INSERT INTO operations ...', data);
  }
}
```

**3. Uso no Repository:**
```typescript
class OperationRepository {
  constructor(
    private dataSource: IOperationDataSource,
    private mapper: OperationMapper
  ) {}
  
  async findById(id: string): Promise<Operation | null> {
    const data = await this.dataSource.getById(id);
    return data ? this.mapper.toDomain(data) : null;
  }
}
```

#### **üé® Padr√µes de Mapeamento:**

**1. Mapeamento Simples:**
```typescript
// Campos com mesmo nome, tipos diferentes
toDomain(data) {
  return {
    id: data.id,
    value: new Money(data.value),
    date: new Date(data.date)
  };
}
```

**2. Mapeamento com Transforma√ß√£o:**
```typescript
// Campos com nomes diferentes
toDomain(data) {
  return {
    id: data.operation_id,
    sourceAccount: data.source_account,
    destinationAccount: data.dest_account
  };
}
```

**3. Mapeamento Condicional:**
```typescript
// L√≥gica condicional baseada em dados
toDomain(data) {
  return {
    id: data.id,
    value: data.nature === 'receita' 
      ? new Money(data.value) 
      : new Money(-data.value)
  };
}
```

**4. Mapeamento com Valida√ß√£o:**
```typescript
// Valida√ß√£o durante convers√£o
toDomain(data) {
  if (!data.id || !data.value) {
    throw new MappingError('Missing required fields', data);
  }
  
  return {
    id: data.id,
    value: new Money(data.value)
  };
}
```

#### **üîß Estrat√©gias Avan√ßadas:**

**1. Mapeamento Autom√°tico:**
```typescript
// Usando decorators ou reflection
class AutoMapper {
  static map<T>(source: any, targetClass: new () => T): T {
    // Mapeamento autom√°tico baseado em propriedades
  }
}
```

**2. Mapeamento com Cache:**
```typescript
// Cache de convers√µes para performance
class CachedMapper {
  private cache = new Map();
  
  toDomain(data) {
    const key = JSON.stringify(data);
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const result = this.performMapping(data);
    this.cache.set(key, result);
    return result;
  }
}
```

**3. Mapeamento com Fallback:**
```typescript
// Estrat√©gia de fallback para dados inv√°lidos
toDomain(data) {
  try {
    return this.strictMapping(data);
  } catch (error) {
    return this.fallbackMapping(data);
  }
}
```

#### **üìã Checklist de Implementa√ß√£o:**

**Antes de Implementar:**
- [ ] Identificar diferen√ßas entre dom√≠nio e dados
- [ ] Definir regras de valida√ß√£o
- [ ] Planejar tratamento de erros
- [ ] Considerar performance

**Durante Implementa√ß√£o:**
- [ ] Implementar convers√£o bidirecional
- [ ] Adicionar valida√ß√µes
- [ ] Tratar casos edge
- [ ] Adicionar logs/monitoramento

**Ap√≥s Implementa√ß√£o:**
- [ ] Testes unit√°rios
- [ ] Testes de integra√ß√£o
- [ ] Performance testing
- [ ] Documenta√ß√£o

#### **üéØ Dicas Pr√°ticas:**

**1. Nomenclatura:**
- Use sufixo `Mapper`: `OperationMapper`
- Use prefixo `to` para m√©todos: `toDomain`, `toData`
- Use nomes descritivos: `fromDatabase`, `toApi`

**2. Organiza√ß√£o:**
- Um mapper por entidade
- Mappers na data layer
- Interfaces no dom√≠nio (se necess√°rio)

**3. Performance:**
- Evite convers√µes desnecess√°rias
- Use cache quando apropriado
- Considere lazy loading

**4. Manuten√ß√£o:**
- Mantenha mappers simples
- Documente regras de convers√£o
- Teste casos edge

Essa abordagem garante que a **convers√£o de dados** seja **robusta**, **test√°vel** e **manuten√≠vel**, permitindo evolu√ß√£o independente das camadas de dom√≠nio e dados.




# Data / models

# Data / repositories