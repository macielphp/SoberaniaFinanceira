import { Budget } from '../../domain/entities/Budget';
import { BudgetItem } from '../../domain/entities/BudgetItem';
import { IBudgetRepository } from '../../domain/repositories/IBudgetRepository';
import { IBudgetItemRepository } from '../../domain/repositories/IBudgetItemRepository';
import { Result, success, failure } from '../../shared/utils/Result';
import { Money } from '../../shared/utils/Money';

export interface CreateBudgetDTO {
  userId: string;
  name: string;
  startPeriod: Date;
  endPeriod: Date;
  type: 'manual';
  totalPlannedValue: Money;
}

export interface UpdateBudgetDTO {
  name?: string;
  startPeriod?: Date;
  endPeriod?: Date;
  totalPlannedValue?: Money;
}

export class BudgetViewModel {
  private _budgets: Budget[] = [];
  private _loading: boolean = false;
  private _error: string | null = null;
  private _selectedBudget: Budget | null = null;

  constructor(
    private budgetRepository: IBudgetRepository,
    private budgetItemRepository: IBudgetItemRepository
  ) {}

  // Getters for state
  get budgets(): Budget[] {
    return this._budgets;
  }

  get loading(): boolean {
    return this._loading;
  }

  get error(): string | null {
    return this._error;
  }

  get selectedBudget(): Budget | null {
    return this._selectedBudget;
  }

  // Setters for state
  set budgets(value: Budget[]) {
    this._budgets = value;
  }

  set loading(value: boolean) {
    this._loading = value;
  }

  set error(value: string | null) {
    this._error = value;
  }

  set selectedBudget(value: Budget | null) {
    this._selectedBudget = value;
  }

  /**
   * Load all budgets
   */
  async loadBudgets(): Promise<void> {
    this.loading = true;
    this.error = null;

    try {
      const budgets = await this.budgetRepository.findAll();
      this.budgets = budgets;
    } catch (error) {
      this.error = error instanceof Error ? error.message : 'Failed to load budgets';
      this.budgets = [];
    } finally {
      this.loading = false;
    }
  }

  /**
   * Load budgets by user
   */
  async loadBudgetsByUser(userId: string): Promise<void> {
    this.loading = true;
    this.error = null;

    try {
      const budgets = await this.budgetRepository.findByUser(userId);
      this.budgets = budgets;
    } catch (error) {
      this.error = error instanceof Error ? error.message : 'Failed to load user budgets';
      this.budgets = [];
    } finally {
      this.loading = false;
    }
  }

  /**
   * Create a new budget
   */
  async createBudget(data: CreateBudgetDTO): Promise<Result<Budget>> {
    this.error = null;

    try {
      const budget = new Budget({
        id: '', // Will be generated by repository
        userId: data.userId,
        name: data.name,
        startPeriod: data.startPeriod,
        endPeriod: data.endPeriod,
        type: data.type,
        totalPlannedValue: data.totalPlannedValue
      });

      const savedBudget = await this.budgetRepository.save(budget);
      return success(savedBudget);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create budget';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Update an existing budget
   */
  async updateBudget(budgetId: string, data: UpdateBudgetDTO): Promise<Result<Budget>> {
    this.error = null;

    try {
      const existingBudget = await this.budgetRepository.findById(budgetId);
      if (!existingBudget) {
        const errorMessage = 'Budget not found';
        this.error = errorMessage;
        return failure(new Error(errorMessage));
      }

      let updatedBudget = existingBudget;

      if (data.name !== undefined) {
        updatedBudget = updatedBudget.updateName(data.name);
      }

      if (data.startPeriod !== undefined) {
        // Note: Budget entity might need a method to update startPeriod
        // For now, we'll create a new budget with updated data
        updatedBudget = new Budget({
          id: existingBudget.id,
          userId: existingBudget.userId,
          name: existingBudget.name,
          startPeriod: data.startPeriod,
          endPeriod: existingBudget.endPeriod,
          type: existingBudget.type,
          totalPlannedValue: existingBudget.totalPlannedValue,
          isActive: existingBudget.isActive,
          status: existingBudget.status,
          createdAt: existingBudget.createdAt
        });
      }

      if (data.endPeriod !== undefined) {
        // Note: Budget entity might need a method to update endPeriod
        // For now, we'll create a new budget with updated data
        updatedBudget = new Budget({
          id: existingBudget.id,
          userId: existingBudget.userId,
          name: existingBudget.name,
          startPeriod: existingBudget.startPeriod,
          endPeriod: data.endPeriod,
          type: existingBudget.type,
          totalPlannedValue: existingBudget.totalPlannedValue,
          isActive: existingBudget.isActive,
          status: existingBudget.status,
          createdAt: existingBudget.createdAt
        });
      }

      if (data.totalPlannedValue !== undefined) {
        updatedBudget = updatedBudget.updateTotalPlannedValue(data.totalPlannedValue);
      }

      const savedBudget = await this.budgetRepository.save(updatedBudget);
      return success(savedBudget);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to update budget';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Delete a budget
   */
  async deleteBudget(budgetId: string): Promise<Result<boolean>> {
    this.error = null;

    try {
      const deleteResult = await this.budgetRepository.delete(budgetId);
      return success(deleteResult);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to delete budget';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Activate a budget
   */
  async activateBudget(budgetId: string): Promise<Result<Budget>> {
    this.error = null;

    try {
      const existingBudget = await this.budgetRepository.findById(budgetId);
      if (!existingBudget) {
        const errorMessage = 'Budget not found';
        this.error = errorMessage;
        return failure(new Error(errorMessage));
      }

      const activatedBudget = existingBudget.activate();
      const savedBudget = await this.budgetRepository.save(activatedBudget);
      return success(savedBudget);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to activate budget';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Deactivate a budget
   */
  async deactivateBudget(budgetId: string): Promise<Result<Budget>> {
    this.error = null;

    try {
      const existingBudget = await this.budgetRepository.findById(budgetId);
      if (!existingBudget) {
        const errorMessage = 'Budget not found';
        this.error = errorMessage;
        return failure(new Error(errorMessage));
      }

      const deactivatedBudget = existingBudget.deactivate();
      const savedBudget = await this.budgetRepository.save(deactivatedBudget);
      return success(savedBudget);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to deactivate budget';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Select a budget by ID
   */
  async selectBudget(budgetId: string): Promise<void> {
    this.error = null;

    try {
      const budget = await this.budgetRepository.findById(budgetId);
      if (!budget) {
        this.error = 'Budget not found';
        this.selectedBudget = null;
        return;
      }

      this.selectedBudget = budget;
    } catch (error) {
      this.error = error instanceof Error ? error.message : 'Failed to find budget';
      this.selectedBudget = null;
    }
  }

  /**
   * Clear error
   */
  clearError(): void {
    this.error = null;
  }

  /**
   * Get active budget from budgets array
   */
  getActiveBudget(): Budget | null {
    return this.budgets.find(budget => budget.isActive) || null;
  }

  /**
   * Get budget by ID from budgets array
   */
  getBudgetById(budgetId: string): Budget | null {
    return this.budgets.find(budget => budget.id === budgetId) || null;
  }

  /**
   * Get budget items for a specific budget
   */
  async getBudgetItems(budgetId: string): Promise<BudgetItem[]> {
    try {
      return await this.budgetItemRepository.findByBudget(budgetId);
    } catch (error) {
      this.error = error instanceof Error ? error.message : 'Failed to load budget items';
      return [];
    }
  }

  /**
   * Create budget item
   */
  async createBudgetItem(budgetItem: BudgetItem): Promise<Result<BudgetItem>> {
    this.error = null;

    try {
      const savedBudgetItem = await this.budgetItemRepository.save(budgetItem);
      return success(savedBudgetItem);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create budget item';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Update budget item
   */
  async updateBudgetItem(budgetItem: BudgetItem): Promise<Result<BudgetItem>> {
    this.error = null;

    try {
      const savedBudgetItem = await this.budgetItemRepository.save(budgetItem);
      return success(savedBudgetItem);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to update budget item';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Delete budget item
   */
  async deleteBudgetItem(budgetItemId: string): Promise<Result<boolean>> {
    this.error = null;

    try {
      const deleteResult = await this.budgetItemRepository.delete(budgetItemId);
      return success(deleteResult);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to delete budget item';
      this.error = errorMessage;
      return failure(new Error(errorMessage));
    }
  }

  /**
   * Calculate budget performance
   */
  async calculateBudgetPerformance(budgetId: string): Promise<{
    plannedTotal: Money;
    actualTotal: Money;
    variance: Money;
    percentageUsed: number;
  }> {
    try {
      const budgetItems = await this.budgetItemRepository.findByBudget(budgetId);
      
      const plannedTotal = budgetItems.reduce(
        (sum, item) => sum.add(item.plannedValue),
        new Money(0, 'BRL')
      );

      const actualTotal = budgetItems.reduce(
        (sum, item) => sum.add(item.actualValue || new Money(0, 'BRL')),
        new Money(0, 'BRL')
      );

      const variance = plannedTotal.subtract(actualTotal);
      const percentageUsed = plannedTotal.value > 0 ? (actualTotal.value / plannedTotal.value) * 100 : 0;

      return {
        plannedTotal,
        actualTotal,
        variance,
        percentageUsed
      };
    } catch (error) {
      this.error = error instanceof Error ? error.message : 'Failed to calculate budget performance';
      return {
        plannedTotal: new Money(0, 'BRL'),
        actualTotal: new Money(0, 'BRL'),
        variance: new Money(0, 'BRL'),
        percentageUsed: 0
      };
    }
  }
}
